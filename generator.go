package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const goStructTemplate = `// Code generated by prompt_codegen. DO NOT EDIT.

package {{.Package}}

{{range .Imports}}import "{{.}}"
{{end}}
{{range .Structs}}
{{range .Comments}}// {{.}}
{{end}}{{if .Fields}}type {{.Name}} struct {
{{range .Fields}}{{if .Comment}}	// {{.Comment}}
{{end}}	{{.Name}} {{.GoType}} ` + "`json:\"{{.JSONTag}}\"{{if .Validation}} validate:\"{{.Validation}}\"{{end}}`" + `
{{end}}}
{{end}}
{{end}}
{{range .Enums}}
// {{.Name}} represents {{.Comment}}
type {{.Name}} {{.Type}}

const (
{{$enumType := .Name}}{{range .Values}}	{{.ConstName}} {{$enumType}} = "{{.Value}}"
{{end}})

{{end}}`

// GenerateGoCode generates Go code from structs and enums
func GenerateGoCode(structs []GoStruct, enums []GoEnum, packageName string) ([]byte, error) {
	tmpl := template.Must(template.New("gocode").Parse(goStructTemplate))

	// Determine required imports
	var imports []string
	// Note: validation tags don't require importing validator package
	// They are just struct tag metadata that can be used by validation libraries

	templateData := TemplateData{
		Package: packageName,
		Structs: structs,
		Enums:   enums,
		Imports: imports,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code if formatting fails
		return buf.Bytes(), fmt.Errorf("failed to format generated code: %w", err)
	}

	return formatted, nil
}

// ProcessFile processes a single prompt file
func (g Generator) ProcessFile(inputFile string) error {
	if g.Verbose {
		fmt.Printf("Processing file: %s\n", inputFile)
	}

	promptFile, err := ParsePromptFile(inputFile)
	if err != nil {
		return fmt.Errorf("failed to parse prompt file: %w", err)
	}

	if !promptFile.HasSchema() {
		if g.Verbose {
			fmt.Printf("Skipping %s: no schema found\n", inputFile)
		}
		return nil
	}

	return g.generateFromPromptFile(promptFile)
}

// ProcessDirectory processes all .prompt files in a directory
func (g Generator) ProcessDirectory(inputDir string) error {
	if g.Verbose {
		fmt.Printf("Processing directory: %s\n", inputDir)
	}

	return filepath.Walk(inputDir, func(path string, _ os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !strings.HasSuffix(path, ".prompt") {
			return nil
		}

		if g.Verbose {
			fmt.Printf("Found prompt file: %s\n", path)
		}

		return g.ProcessFile(path)
	})
}

// generateFromPromptFile generates Go code from a parsed prompt file
func (g Generator) generateFromPromptFile(promptFile *PromptFile) error {
	requestName, responseName := FilenameToStructNames(promptFile.Filename)

	var structs []GoStruct
	var allEnums []GoEnum

	// Generate request struct if input schema exists
	if promptFile.GetInputSchema() != nil {
		fields, enums, nestedStructs, err := ParseSchemaWithStructs(
			promptFile.GetInputSchema(),
			promptFile.GetRequiredInputFields(),
		)
		if err != nil {
			return fmt.Errorf("failed to parse input schema: %w", err)
		}

		if len(fields) > 0 {
			structs = append(structs, GoStruct{
				Name:   requestName,
				Fields: fields,
				Comments: []string{
					fmt.Sprintf(
						"%s represents the input for %s",
						requestName,
						getPromptDescription(promptFile),
					),
				},
			})
		}

		// Add nested structs from schema parsing
		structs = append(structs, nestedStructs...)
		allEnums = append(allEnums, enums...)
	}

	// Generate response struct if output schema exists
	if promptFile.GetOutputSchema() != nil {
		fields, enums, nestedStructs, err := ParseSchemaWithStructs(
			promptFile.GetOutputSchema(),
			promptFile.GetRequiredOutputFields(),
		)
		if err != nil {
			return fmt.Errorf("failed to parse output schema: %w", err)
		}

		if len(fields) > 0 {
			structs = append(structs, GoStruct{
				Name:   responseName,
				Fields: fields,
				Comments: []string{
					fmt.Sprintf(
						"%s represents the output for %s",
						responseName,
						getPromptDescription(promptFile),
					),
				},
			})
		}

		// Add nested structs from schema parsing
		structs = append(structs, nestedStructs...)
		allEnums = append(allEnums, enums...)
	}

	if len(structs) == 0 {
		if g.Verbose {
			fmt.Printf("No structs to generate for %s\n", promptFile.Filename)
		}
		return nil
	}

	// Generate Go code
	code, err := GenerateGoCode(structs, allEnums, g.PackageName)
	if err != nil {
		return fmt.Errorf("failed to generate Go code: %w", err)
	}

	// Determine output file path
	outputFile := g.getOutputFilePath(promptFile.Filename)

	// Write generated code to file
	if err := os.WriteFile(outputFile, code, 0o600); err != nil {
		return fmt.Errorf("failed to write output file %s: %w", outputFile, err)
	}

	fmt.Printf("Generated %s\n", outputFile)
	return nil
}

// getOutputFilePath determines the output file path
func (g Generator) getOutputFilePath(inputFile string) string {
	baseName := strings.TrimSuffix(filepath.Base(inputFile), ".prompt")
	outputFileName := baseName + ".gen.go"

	if g.OutputDir != "" {
		return filepath.Join(g.OutputDir, outputFileName)
	}

	// Output in the same directory as input file
	inputDir := filepath.Dir(inputFile)
	return filepath.Join(inputDir, outputFileName)
}

// getPromptDescription extracts a description from the prompt file
func getPromptDescription(promptFile *PromptFile) string {
	baseName := strings.TrimSuffix(filepath.Base(promptFile.Filename), ".prompt")
	return strings.ReplaceAll(baseName, "_", " ")
}
