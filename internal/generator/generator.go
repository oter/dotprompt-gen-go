package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/oter/dotprompt-gen-go/internal/model"
	"github.com/oter/dotprompt-gen-go/internal/parser"
	"github.com/oter/dotprompt-gen-go/internal/schema"
)

const goStructTemplate = `// Code generated by prompt_codegen. DO NOT EDIT.

package {{.Package}}

{{range .Imports}}import "{{.}}"
{{end}}
{{range .Structs}}
{{range .Comments}}// {{.}}
{{end}}{{if .Fields}}type {{.Name}} struct {
{{range .Fields}}{{if .Comment}}	// {{.Comment}}
{{end}}	{{.Name}} {{.GoType}} ` + "`json:\"{{.JSONTag}}\"{{if .Validation}} validate:\"{{.Validation}}\"{{end}}`" + `
{{end}}}
{{end}}
{{end}}
{{range .Enums}}
// {{.Name}} represents {{.Comment}}
type {{.Name}} {{.Type}}

const (
{{$enumType := .Name}}{{range .Values}}	{{.ConstName}} {{$enumType}} = "{{.Value}}"
{{end}})

{{end}}`

// GenerateGoCode generates Go code from structs and enums
func GenerateGoCode(
	structs []model.GoStruct,
	enums []model.GoEnum,
	packageName string,
) ([]byte, error) {
	tmpl := template.Must(template.New("gocode").Parse(goStructTemplate))

	// Determine required imports
	var imports []string
	// Note: validation tags don't require importing validator package
	// They are just struct tag metadata that can be used by validation libraries

	templateData := model.TemplateData{
		Package: packageName,
		Structs: structs,
		Enums:   enums,
		Imports: imports,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code if formatting fails
		return buf.Bytes(), fmt.Errorf("failed to format generated code: %w", err)
	}

	return formatted, nil
}

// ProcessFile processes a single prompt file
func ProcessFile(g model.Generator, inputFile string) error {
	if g.Verbose {
		fmt.Printf("Processing file: %s\n", inputFile)
	}

	promptFile, err := parser.ParsePromptFile(inputFile)
	if err != nil {
		return fmt.Errorf("failed to parse prompt file: %w", err)
	}

	if !parser.HasSchema(promptFile) {
		if g.Verbose {
			fmt.Printf("Skipping %s: no schema found\n", inputFile)
		}
		return nil
	}

	return generateFromPromptFile(g, promptFile)
}

// ProcessDirectory processes all .prompt files in a directory
func ProcessDirectory(g model.Generator, inputDir string) error {
	if g.Verbose {
		fmt.Printf("Processing directory: %s\n", inputDir)
	}

	return filepath.Walk(inputDir, func(path string, _ os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !strings.HasSuffix(path, ".prompt") {
			return nil
		}

		if g.Verbose {
			fmt.Printf("Found prompt file: %s\n", path)
		}

		return ProcessFile(g, path)
	})
}

// generateFromPromptFile generates Go code from a parsed prompt file
func generateFromPromptFile(g model.Generator, promptFile *model.PromptFile) error {
	requestName, responseName := FilenameToStructNames(promptFile.Filename)

	var structs []model.GoStruct
	var allEnums []model.GoEnum

	// Generate request struct if input schema exists
	if parser.GetInputSchema(promptFile) != nil {
		fields, enums, nestedStructs, err := schema.ParseSchemaWithStructs(
			parser.GetInputSchema(promptFile),
			parser.GetRequiredInputFields(promptFile),
		)
		if err != nil {
			return fmt.Errorf("failed to parse input schema: %w", err)
		}

		if len(fields) > 0 {
			structs = append(structs, model.GoStruct{
				Name:   requestName,
				Fields: fields,
				Comments: []string{
					fmt.Sprintf(
						"%s represents the input for %s",
						requestName,
						getPromptDescription(promptFile),
					),
				},
			})
		}

		// Add nested structs from schema parsing
		structs = append(structs, nestedStructs...)
		allEnums = append(allEnums, enums...)
	}

	// Generate response struct if output schema exists
	if parser.GetOutputSchema(promptFile) != nil {
		fields, enums, nestedStructs, err := schema.ParseSchemaWithStructs(
			parser.GetOutputSchema(promptFile),
			parser.GetRequiredOutputFields(promptFile),
		)
		if err != nil {
			return fmt.Errorf("failed to parse output schema: %w", err)
		}

		if len(fields) > 0 {
			structs = append(structs, model.GoStruct{
				Name:   responseName,
				Fields: fields,
				Comments: []string{
					fmt.Sprintf(
						"%s represents the output for %s",
						responseName,
						getPromptDescription(promptFile),
					),
				},
			})
		}

		// Add nested structs from schema parsing
		structs = append(structs, nestedStructs...)
		allEnums = append(allEnums, enums...)
	}

	if len(structs) == 0 {
		if g.Verbose {
			fmt.Printf("No structs to generate for %s\n", promptFile.Filename)
		}
		return nil
	}

	// Generate Go code
	code, err := GenerateGoCode(structs, allEnums, g.PackageName)
	if err != nil {
		return fmt.Errorf("failed to generate Go code: %w", err)
	}

	// Determine output file path
	outputFile := getOutputFilePath(g, promptFile.Filename)

	// Write generated code to file
	if err := os.WriteFile(outputFile, code, 0o600); err != nil {
		return fmt.Errorf("failed to write output file %s: %w", outputFile, err)
	}

	fmt.Printf("Generated %s\n", outputFile)
	return nil
}

// getOutputFilePath determines the output file path
func getOutputFilePath(g model.Generator, inputFile string) string {
	baseName := strings.TrimSuffix(filepath.Base(inputFile), ".prompt")
	outputFileName := baseName + ".gen.go"

	if g.OutputDir != "" {
		return filepath.Join(g.OutputDir, outputFileName)
	}

	// Output in the same directory as input file
	inputDir := filepath.Dir(inputFile)
	return filepath.Join(inputDir, outputFileName)
}

// getPromptDescription extracts a description from the prompt file
func getPromptDescription(promptFile *model.PromptFile) string {
	baseName := strings.TrimSuffix(filepath.Base(promptFile.Filename), ".prompt")
	return strings.ReplaceAll(baseName, "_", " ")
}
