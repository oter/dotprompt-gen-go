package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/oter/dotprompt-gen-go/internal/ast"
	"github.com/oter/dotprompt-gen-go/internal/codegen"
	"github.com/oter/dotprompt-gen-go/internal/parser"
)

// Version is the version of dotprompt-gen-go used to generate code
// This should be set at build time using -ldflags "-X
// github.com/oter/dotprompt-gen-go/internal/generator.Version=v1.2.3".
var Version = "dev" //nolint:gochecknoglobals // set at build time

const goStructTemplate = `// Code generated by dotprompt-gen-go {{.Version}}. DO NOT EDIT.

package {{.Package}}

{{range .Imports}}import "{{.}}"
{{end}}
{{range .Structs}}
{{range .Comments}}// {{.}}
{{end}}{{if .Fields}}type {{.Name}} struct {
{{range .Fields}}{{if .Comment}}	// {{.Comment}}
{{end}}	{{.Name}} {{.GoType}} ` + "`json:\"{{.JSONTag}}\"`" + `
{{end}}}
{{end}}
{{end}}
{{range .Structs}}{{if .NeedsValidation}}
// Validate validates all fields in {{.Name}}
func (s {{.Name}}) Validate() error {
{{if .HasValidationFields}}	fieldValidations := map[string]validator.Validator{
{{range .Fields}}{{if .NeedsValidation}}		"{{.JSONTag}}": s.{{.Name}},
{{end}}{{end}}	}
	return validator.ValidateFields(fieldValidations)
{{else}}	return nil
{{end}}}
{{end}}
{{end}}
{{range .Enums}}
// {{.Name}} represents {{.Comment}}
type {{.Name}} {{.Type}}

const (
{{$enumType := .Name}}{{range .Values}}	{{.ConstName}} {{$enumType}} = "{{.Value}}"
{{end}})

// Validate checks if the {{.Name}} value is valid
func (e {{.Name}}) Validate() error {
	switch e {
	case {{$enumType := .Name}}{{range $i, $v := .Values}}{{if $i}}, {{end}}{{$v.ConstName}}{{end}}:
		return nil
	default:
		return fmt.Errorf("invalid {{.Name}} value: %q, must be one of: {{range $i, $v := .Values}}{{if $i}}, {{end}}{{$v.Value}}{{end}}", {{if eq .Type "string"}}string(e){{else}}e{{end}})
	}
}

{{end}}`

// GenerateGoCode generates Go code from structs and enums.
func GenerateGoCode(
	structs []codegen.GoStruct,
	enums []codegen.GoEnum,
	packageName string,
) ([]byte, error) {
	tmpl := template.Must(template.New("gocode").Parse(goStructTemplate))

	// Determine required imports
	var imports []string
	// Note: validation tags don't require importing validator package
	// They are just struct tag metadata that can be used by validation libraries

	// Add fmt import if we have enums (needed for validation error messages)
	if len(enums) > 0 {
		imports = append(imports, "fmt")
	}

	// Add validator import if we have actual validation calls (not just empty Validate() methods)
	hasValidationCalls := false
	for _, s := range structs {
		if s.NeedsValidation() && s.HasValidationFields() {
			hasValidationCalls = true

			break
		}
	}
	if hasValidationCalls {
		imports = append(imports, "github.com/oter/dotprompt-gen-go/pkg/validator")
	}

	templateData := codegen.TemplateData{
		Version: Version,
		Package: packageName,
		Imports: imports,
		Enums:   enums,
		Structs: structs,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code if formatting fails
		return buf.Bytes(), fmt.Errorf("failed to format generated code: %w", err)
	}

	return formatted, nil
}

// ProcessFile processes a single prompt file.
func ProcessFile(g codegen.Generator, inputFile string) error {
	if g.Verbose {
		fmt.Printf("Processing file: %s\n", inputFile)
	}

	promptFile, err := parser.ParsePromptFile(inputFile)
	if err != nil {
		return fmt.Errorf("failed to parse prompt file: %w", err)
	}

	if !promptFile.HasSchema() {
		if g.Verbose {
			fmt.Printf("Skipping %s: no schema found\n", inputFile)
		}

		return nil
	}

	return generateFromPromptFile(g, promptFile)
}

// ProcessDirectory processes all .prompt files in a directory.
func ProcessDirectory(g codegen.Generator, inputDir string) error {
	if g.Verbose {
		fmt.Printf("Processing directory: %s\n", inputDir)
	}

	err := filepath.Walk(inputDir, func(path string, _ os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !strings.HasSuffix(path, ".prompt") {
			return nil
		}

		if g.Verbose {
			fmt.Printf("Found prompt file: %s\n", path)
		}

		return ProcessFile(g, path)
	})
	if err != nil {
		return fmt.Errorf("failed to process directory %s: %w", inputDir, err)
	}

	return nil
}

// generateFromPromptFile generates Go code from a parsed prompt file.
func generateFromPromptFile(g codegen.Generator, promptFile *ast.PromptFile) error {
	requestName, responseName := FilenameToStructNames(promptFile.Filename)

	var (
		structs  []codegen.GoStruct
		allEnums []codegen.GoEnum
	)

	// Generate request struct if input schema exists

	if promptFile.GetInputSchema() != nil {
		fields, enums, nestedStructs, err := parseSchemaWithNestedFieldOrder(
			promptFile.GetInputSchema(),
			promptFile.GetRequiredInputFields(),
			parser.SchemaTypeInput,
			promptFile.InputFieldOrder,
			promptFile.InputNestedFieldOrder,
		)
		if err != nil {
			return fmt.Errorf("failed to parse input schema: %w", err)
		}

		if len(fields) > 0 {
			structs = append(structs, codegen.GoStruct{
				Name: requestName,
				Comments: []string{
					fmt.Sprintf(
						"%s represents the input for %s",
						requestName,
						getPromptDescription(promptFile),
					),
				},
				Fields:   fields,
				IsInput:  true,
				IsOutput: false,
			})
		}

		// Add nested structs from schema parsing with validation
		for _, nestedStruct := range nestedStructs {
			nestedStruct.IsInput = false
			nestedStruct.IsOutput = false // Nested structs are neither input nor output, but can still have validation
			structs = append(structs, nestedStruct)
		}
		allEnums = append(allEnums, enums...)
	}

	// Generate response struct if output schema exists
	if promptFile.GetOutputSchema() != nil {
		fields, enums, nestedStructs, err := parseSchemaWithNestedFieldOrder(
			promptFile.GetOutputSchema(),
			promptFile.GetRequiredOutputFields(),
			parser.SchemaTypeOutput,
			promptFile.OutputFieldOrder,
			promptFile.OutputNestedFieldOrder,
		)
		if err != nil {
			return fmt.Errorf("failed to parse output schema: %w", err)
		}

		if len(fields) > 0 {
			responseStruct := codegen.GoStruct{
				Name: responseName,
				Comments: []string{
					fmt.Sprintf(
						"%s represents the output for %s",
						responseName,
						getPromptDescription(promptFile),
					),
				},
				Fields:   fields,
				IsInput:  false,
				IsOutput: true,
			}
			structs = append(structs, responseStruct)
		}

		// Add nested structs from schema parsing with validation
		for _, nestedStruct := range nestedStructs {
			nestedStruct.IsInput = false
			nestedStruct.IsOutput = false // Nested structs are neither input nor output, but can still have validation
			structs = append(structs, nestedStruct)
		}
		allEnums = append(allEnums, enums...)
	}

	if len(structs) == 0 {
		if g.Verbose {
			fmt.Printf("No structs to generate for %s\n", promptFile.Filename)
		}

		return nil
	}

	// Generate Go code
	code, err := GenerateGoCode(structs, allEnums, g.PackageName)
	if err != nil {
		return fmt.Errorf("failed to generate Go code: %w", err)
	}

	// Determine output file path
	outputFile := getOutputFilePath(g, promptFile.Filename)

	// Write generated code to file
	if err := os.WriteFile(outputFile, code, 0o600); err != nil {
		return fmt.Errorf("failed to write output file %s: %w", outputFile, err)
	}

	fmt.Printf("Generated %s\n", outputFile)

	return nil
}

// parseSchemaWithNestedFieldOrder is a wrapper that calls the appropriate parser with nested field order support.
func parseSchemaWithNestedFieldOrder(
	schema any,
	requiredFields []string,
	schemaType parser.SchemaType,
	fieldOrder []string,
	nestedFieldOrder map[string][]string,
) ([]codegen.GoField, []codegen.GoEnum, []codegen.GoStruct, error) {
	// For now, we only support nested field order for JSON Schema
	// Picoschema doesn't support nested objects yet
	if parser.IsJSONSchema(schema) {
		return parser.ParseJSONSchemaWithNestedFieldOrder(schema, requiredFields, schemaType, fieldOrder, nestedFieldOrder)
	}

	// Fall back to regular parsing for other schema types
	return parser.ParseSchemaWithStructsAndFieldOrder(schema, requiredFields, schemaType, fieldOrder)
}

// getOutputFilePath determines the output file path.
func getOutputFilePath(g codegen.Generator, inputFile string) string {
	baseName := strings.TrimSuffix(filepath.Base(inputFile), ".prompt")
	outputFileName := baseName + ".gen.go"

	if g.OutputDir != "" {
		return filepath.Join(g.OutputDir, outputFileName)
	}

	// Output in the same directory as input file
	inputDir := filepath.Dir(inputFile)

	return filepath.Join(inputDir, outputFileName)
}

// getPromptDescription extracts a description from the prompt file.
func getPromptDescription(promptFile *ast.PromptFile) string {
	baseName := strings.TrimSuffix(filepath.Base(promptFile.Filename), ".prompt")

	return strings.ReplaceAll(baseName, "_", " ")
}
